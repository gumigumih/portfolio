# エンジニアリング原則

## 1. 再利用可能な部品設計
- コンポーネント化とモジュール設計により、開発効率と保守性を向上させる
- UIコンポーネントの抽象化
- 型安全性の確保
- プロパティベースの設計
- カスタムフックの活用

## 2. 責務の分離と疎結合
- 単一責任原則に従い、各コンポーネントの責務を明確に分離する
- データ層とUI層の分離
- ビジネスロジックの独立化
- 定数とユーティリティの外部化
- 依存関係の最小化

## 3. 技術選定の最適化
- 既存の知見を最大限活かしつつ、プロジェクトに最適な技術を選定する
- 既存技術スタックの活用
- 学習コストの考慮
- チームスキルの最大化
- 将来性と安定性のバランス

## 4. フレームワークのベストプラクティス
- React、TypeScript等の最新技術のベストプラクティスに従った実装
- React Hooksの適切な使用
- TypeScriptによる型安全性
- パフォーマンス最適化
- アクセシビリティの考慮

## コード品質ガイドライン

### コンポーネント設計
- 単一責任原則に従う
- 再利用可能なUIコンポーネントを作成
- プロパティを通じた疎結合な通信
- 型安全性を重視

### データ管理
- データとロジックの分離
- 定数は`src/constants/`に集約
- ユーティリティ関数は`src/utils/`に集約
- 型定義は適切なインターフェースで管理

### ファイル構造
- 機能別のディレクトリ構造
- 関連するファイルのグループ化
- 明確な命名規則
- インデックスファイルでのエクスポート管理

### パフォーマンス
- 不要な再レンダリングの回避
- メモ化の適切な使用
- バンドルサイズの最適化
- 遅延読み込みの活用

## 命名規則
- コンポーネント: PascalCase (例: `Button`, `SkillLevel`)
- ファイル: kebab-case (例: `skill-level.tsx`, `ai-tools.ts`)
- 定数: UPPER_SNAKE_CASE (例: `PROJECT_TYPE_LABELS`)
- 関数: camelCase (例: `formatProjectPeriod`)

## コメント・ドキュメント
- 複雑なロジックには適切なコメント
- コンポーネントの目的と使用方法を明記
- TypeScriptインターフェースで型定義
- READMEファイルの定期的な更新
